#pragma once

#include <ogdfWrapper/ogdfWrapper.hpp>
#include <ogdfWrapper/types.hpp>

#include <fstream>
#include <string>
#include <unordered_set>

enum class StepType {
    SET,
    BACKTRACK,
    CONFLICT,
    LEVEL,
    BRANCH,
    RESTART,
    LEARNEDCLAUSE,
    UNLEARNEDCLAUSE
};

struct Step {
    StepType type;
    // either node or backtrack level or restart number
    union {
        uint data;  // for where we don't care what kind of step it is
        uint level;
        uint numberOfRestarts;
        uint variable;
    };
    bool nodeValue;
    graphdrawer::NodeID inline nodeID() const {
        return {variable, graphdrawer::NodeType::LITERAL};
    };
};

struct Clause {
    StepType type;
    uint id;
    std::vector<uint> variables;
    graphdrawer::NodeID inline nodeID() const {
        return {id, graphdrawer::NodeType::LITERAL};
    };
};

/*
    Creates and holds Graph of SAT instance through ogdfWrapper
    Reads and processes information from tracefile
        tracefile is generated by minisat (sat-solver)
*/
class Stepper {
public:
    void initialize(std::string cnfPath, bool forceSolve, bool showSimplified);
    /*
        read,parse and execute one step of the tracefile
    */
    void step();

    /*
        execute steps until the next branch step
    */
    void branch();

    /*
        execute steps until the next conflict step
    */
    void nextConflict();

    /*
        skip forward to the next restart step
    */
    void nextRestart();

    /*
        skip forward to the last restart step in the tracefile
    */
    void lastRestart();

    /*
        backtrack to a given level
    */
    void backtrack(int level);

    /*
        returns whether there are any steps left
    */
    bool isFinished();
    /*
        remove edges that have at least one endpoint with degree higher than the
       parameter
    */
    void cull(int degree);
    void relayout();

    /*
        cluster and color the graph using the louvain method
    */
    void cluster();
    const std::string getSVGPath() const;

    /*
        color all nodes with placements inside the given rectangle
    */
    void colorNodesInRect(float xMin, float xMax, float yMin, float yMax,
                          graphdrawer::NodeColor color);

protected:
    void loadFromGML(const std::string& gmlPath);
    void readTrace(const std::string& tracePath);
    /*
        Reads and parses one entry from the tracefile
    */
    StepType readTraceStep();

    /*
        Reads one entry from the tracefile
        Tracefile is in binary. Format is char followed by int
    */
    void readBlock(char& type, int& data);
    void applyClause(int i = -1);
    // returns true if a node has been colored
    bool applyStep(int i = -1);
    void stepUntil(StepType stepType, bool layout);
    void printProgress();

    std::vector<Step> m_eventStack;
    std::vector<Clause> m_learnedClauses;
    graphdrawer::ogdfWrapper m_graph;
    std::ifstream m_tracefile;
    int64_t m_tracefileSize;
    int64_t m_readBlocks;
    int m_numberOfRestarts;
    int m_currentLevel = 0;

    const std::string conversionScript = "cnfToGML.py";
    const std::string minisat = "./minisat-solver";
    const std::string outputPath = "data/";
    const std::string scriptPath = "../scripts/";
    const std::string clusteringScript = "louvain_clustering.py";

    std::string m_svgPath;
    std::string m_gmlPath;
    std::string m_clusterPath;

    int m_lastCull;
    int m_branchCount;

    // stores the colors of nodes colored by something other than a step
    std::unordered_map<graphdrawer::NodeID, graphdrawer::NodeColor>
        m_coloredNodes;
};
